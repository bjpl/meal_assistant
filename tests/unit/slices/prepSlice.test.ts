import { configureStore } from '@reduxjs/toolkit';
import prepReducer, {
  startSession,
  endSession,
  updateTaskStatus,
  setEquipmentStatus,
  resetEquipment,
  addTemplate,
  deleteTemplate,
  setLoading,
  setError,
  fetchCurrentSession,
  startSessionAsync,
  endSessionAsync,
  updateTaskStatusAsync,
  fetchTemplates,
  createTemplateAsync,
  fetchPastSessions,
} from '../../../src/mobile/store/slices/prepSlice';
import { PrepSession, PrepTask, Equipment } from '../../../src/mobile/types';
import { prepApi } from '../../../src/mobile/services/apiService';

// Mock the API service
jest.mock('../../../src/mobile/services/apiService');

const mockedPrepApi = prepApi as jest.Mocked<typeof prepApi>;

// Helper to create a test store
const createTestStore = (initialState?: any) => {
  return configureStore({
    reducer: {
      prep: prepReducer,
    },
    preloadedState: initialState ? { prep: initialState } : undefined,
  });
};

// Mock data factories
const createMockTask = (overrides?: Partial<PrepTask>): PrepTask => ({
  id: 'task-1',
  name: 'Chop vegetables',
  duration: 15,
  status: 'pending',
  equipment: 'Cutting Board',
  dependencies: [],
  ...overrides,
});

const createMockSession = (overrides?: Partial<PrepSession>): PrepSession => ({
  id: 'session-1',
  name: 'Dinner Prep',
  status: 'pending',
  tasks: [createMockTask()],
  startTime: '2025-01-15T18:00:00Z',
  estimatedDuration: 30,
  ...overrides,
});

const createMockEquipment = (overrides?: Partial<Equipment>): Equipment => ({
  id: 'eq-1',
  name: 'Stovetop',
  status: 'available',
  icon: 'ðŸ³',
  ...overrides,
});

describe('prepSlice', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // =============================================================================
  // INITIAL STATE
  // =============================================================================

  describe('Initial State', () => {
    test('should have correct initial state structure', () => {
      const store = createTestStore();
      const state = store.getState().prep;

      expect(state).toEqual({
        currentSession: null,
        pastSessions: [],
        equipment: expect.arrayContaining([
          expect.objectContaining({ name: 'Stovetop', status: 'available' }),
          expect.objectContaining({ name: 'Oven', status: 'available' }),
          expect.objectContaining({ name: 'Rice Cooker', status: 'available' }),
        ]),
        templates: [],
        loading: false,
        error: null,
      });
    });

    test('should initialize with default equipment', () => {
      const store = createTestStore();
      const state = store.getState().prep;

      expect(state.equipment).toHaveLength(8);
      expect(state.equipment.map(eq => eq.name)).toEqual([
        'Stovetop',
        'Oven',
        'Rice Cooker',
        'Cutting Board',
        'Blender',
        'Instant Pot',
        'Air Fryer',
        'Grill Pan',
      ]);
    });

    test('should have all equipment available initially', () => {
      const store = createTestStore();
      const state = store.getState().prep;

      state.equipment.forEach(eq => {
        expect(eq.status).toBe('available');
        expect(eq.currentTask).toBeUndefined();
      });
    });
  });

  // =============================================================================
  // PREP SESSION MANAGEMENT - SYNC REDUCERS
  // =============================================================================

  describe('Session Management - Sync', () => {
    test('should start a new session with in-progress status', () => {
      const store = createTestStore();
      const session = createMockSession();

      store.dispatch(startSession(session));
      const state = store.getState().prep;

      // Compare without startTime since it's regenerated by the slice
      const { startTime: _ignore, ...sessionWithoutTime } = session;
      expect(state.currentSession).toMatchObject({
        ...sessionWithoutTime,
        status: 'in-progress',
      });
      expect(state.currentSession?.startTime).toBeTruthy();
    });

    test('should set startTime when starting a session', () => {
      const store = createTestStore();
      const session = createMockSession();
      const beforeTime = Date.now();

      store.dispatch(startSession(session));

      const afterTime = Date.now();
      const state = store.getState().prep;

      expect(state.currentSession?.startTime).toBeTruthy();
      // Convert ISO string to timestamp for comparison
      const sessionStartTime = new Date(state.currentSession!.startTime).getTime();
      expect(sessionStartTime).toBeGreaterThanOrEqual(beforeTime);
      expect(sessionStartTime).toBeLessThanOrEqual(afterTime);
    });

    test('should end current session and move to past sessions', () => {
      const session = createMockSession({ status: 'in-progress' });
      const store = createTestStore({
        currentSession: session,
        pastSessions: [],
        equipment: [createMockEquipment({ status: 'in-use' })],
        templates: [],
        loading: false,
        error: null,
      });

      store.dispatch(endSession());
      const state = store.getState().prep;

      expect(state.currentSession).toBeNull();
      expect(state.pastSessions).toHaveLength(1);
      expect(state.pastSessions[0].status).toBe('completed');
      expect(state.pastSessions[0].endTime).toBeTruthy();
    });

    test('should set equipment to dirty when ending session', () => {
      const session = createMockSession({ status: 'in-progress' });
      const equipment: Equipment[] = [
        createMockEquipment({ id: '1', status: 'in-use' }),
        createMockEquipment({ id: '2', status: 'available' }),
        createMockEquipment({ id: '3', status: 'in-use' }),
      ];

      const store = createTestStore({
        currentSession: session,
        pastSessions: [],
        equipment,
        templates: [],
        loading: false,
        error: null,
      });

      store.dispatch(endSession());
      const state = store.getState().prep;

      expect(state.equipment[0].status).toBe('dirty');
      expect(state.equipment[1].status).toBe('available');
      expect(state.equipment[2].status).toBe('dirty');
    });

    test('should do nothing when ending session with no current session', () => {
      const store = createTestStore();

      store.dispatch(endSession());
      const state = store.getState().prep;

      expect(state.currentSession).toBeNull();
      expect(state.pastSessions).toHaveLength(0);
    });

    test('should preserve session data when moving to past sessions', () => {
      const task1 = createMockTask({ id: 'task-1', name: 'Chop onions' });
      const task2 = createMockTask({ id: 'task-2', name: 'SautÃ© vegetables' });
      const session = createMockSession({
        id: 'session-1',
        name: 'Dinner Prep',
        tasks: [task1, task2],
        status: 'in-progress',
      });

      const store = createTestStore({
        currentSession: session,
        pastSessions: [],
        equipment: [],
        templates: [],
        loading: false,
        error: null,
      });

      store.dispatch(endSession());
      const state = store.getState().prep;

      expect(state.pastSessions[0]).toMatchObject({
        id: 'session-1',
        name: 'Dinner Prep',
        tasks: [task1, task2],
      });
    });
  });

  // =============================================================================
  // TASK SCHEDULING & STATUS MANAGEMENT
  // =============================================================================

  describe('Task Management', () => {
    test('should update task status in current session', () => {
      const task = createMockTask({ id: 'task-1', status: 'pending' });
      const session = createMockSession({ tasks: [task] });

      const store = createTestStore({
        currentSession: session,
        pastSessions: [],
        equipment: [],
        templates: [],
        loading: false,
        error: null,
      });

      store.dispatch(updateTaskStatus({ taskId: 'task-1', status: 'in-progress' }));
      const state = store.getState().prep;

      expect(state.currentSession?.tasks[0].status).toBe('in-progress');
    });

    test('should update task status to completed', () => {
      const task = createMockTask({ id: 'task-1', status: 'in-progress' });
      const session = createMockSession({ tasks: [task] });

      const store = createTestStore({
        currentSession: session,
        pastSessions: [],
        equipment: [],
        templates: [],
        loading: false,
        error: null,
      });

      store.dispatch(updateTaskStatus({ taskId: 'task-1', status: 'completed' }));
      const state = store.getState().prep;

      expect(state.currentSession?.tasks[0].status).toBe('completed');
    });

    test('should do nothing when updating task with no current session', () => {
      const store = createTestStore();

      store.dispatch(updateTaskStatus({ taskId: 'task-1', status: 'completed' }));
      const state = store.getState().prep;

      expect(state.currentSession).toBeNull();
    });

    test('should do nothing when updating non-existent task', () => {
      const task = createMockTask({ id: 'task-1', status: 'pending' });
      const session = createMockSession({ tasks: [task] });

      const store = createTestStore({
        currentSession: session,
        pastSessions: [],
        equipment: [],
        templates: [],
        loading: false,
        error: null,
      });

      store.dispatch(updateTaskStatus({ taskId: 'task-999', status: 'completed' }));
      const state = store.getState().prep;

      expect(state.currentSession?.tasks[0].status).toBe('pending');
    });

    test('should handle multiple tasks with different statuses', () => {
      const tasks = [
        createMockTask({ id: 'task-1', status: 'pending' }),
        createMockTask({ id: 'task-2', status: 'pending' }),
        createMockTask({ id: 'task-3', status: 'pending' }),
      ];
      const session = createMockSession({ tasks });

      const store = createTestStore({
        currentSession: session,
        pastSessions: [],
        equipment: [],
        templates: [],
        loading: false,
        error: null,
      });

      store.dispatch(updateTaskStatus({ taskId: 'task-1', status: 'completed' }));
      store.dispatch(updateTaskStatus({ taskId: 'task-2', status: 'in-progress' }));

      const state = store.getState().prep;

      expect(state.currentSession?.tasks[0].status).toBe('completed');
      expect(state.currentSession?.tasks[1].status).toBe('in-progress');
      expect(state.currentSession?.tasks[2].status).toBe('pending');
    });
  });

  // =============================================================================
  // EQUIPMENT TRACKING
  // =============================================================================

  describe('Equipment Management', () => {
    test('should update equipment status to in-use', () => {
      const store = createTestStore();

      store.dispatch(setEquipmentStatus({
        equipmentId: '1',
        status: 'in-use',
        currentTask: 'task-1',
      }));

      const state = store.getState().prep;
      const equipment = state.equipment.find(eq => eq.id === '1');

      expect(equipment?.status).toBe('in-use');
      expect(equipment?.currentTask).toBe('task-1');
    });

    test('should update equipment status to dirty', () => {
      const store = createTestStore();

      store.dispatch(setEquipmentStatus({
        equipmentId: '1',
        status: 'dirty',
      }));

      const state = store.getState().prep;
      const equipment = state.equipment.find(eq => eq.id === '1');

      expect(equipment?.status).toBe('dirty');
    });

    test('should update equipment status to available and clear current task', () => {
      const equipment: Equipment[] = [
        createMockEquipment({ id: '1', status: 'in-use', currentTask: 'task-1' }),
      ];

      const store = createTestStore({
        currentSession: null,
        pastSessions: [],
        equipment,
        templates: [],
        loading: false,
        error: null,
      });

      store.dispatch(setEquipmentStatus({
        equipmentId: '1',
        status: 'available',
      }));

      const state = store.getState().prep;
      const updatedEquipment = state.equipment.find(eq => eq.id === '1');

      expect(updatedEquipment?.status).toBe('available');
    });

    test('should do nothing when updating non-existent equipment', () => {
      const store = createTestStore();
      const initialEquipment = store.getState().prep.equipment;

      store.dispatch(setEquipmentStatus({
        equipmentId: 'non-existent',
        status: 'in-use',
      }));

      const state = store.getState().prep;
      expect(state.equipment).toEqual(initialEquipment);
    });

    test('should reset all equipment to available', () => {
      const equipment: Equipment[] = [
        createMockEquipment({ id: '1', status: 'in-use', currentTask: 'task-1' }),
        createMockEquipment({ id: '2', status: 'dirty', currentTask: 'task-2' }),
        createMockEquipment({ id: '3', status: 'available' }),
      ];

      const store = createTestStore({
        currentSession: null,
        pastSessions: [],
        equipment,
        templates: [],
        loading: false,
        error: null,
      });

      store.dispatch(resetEquipment());
      const state = store.getState().prep;

      state.equipment.forEach(eq => {
        expect(eq.status).toBe('available');
        expect(eq.currentTask).toBeUndefined();
      });
    });

    test('should handle multiple equipment status updates', () => {
      const store = createTestStore();

      store.dispatch(setEquipmentStatus({ equipmentId: '1', status: 'in-use', currentTask: 'task-1' }));
      store.dispatch(setEquipmentStatus({ equipmentId: '2', status: 'in-use', currentTask: 'task-2' }));
      store.dispatch(setEquipmentStatus({ equipmentId: '3', status: 'dirty' }));

      const state = store.getState().prep;

      expect(state.equipment.find(eq => eq.id === '1')?.status).toBe('in-use');
      expect(state.equipment.find(eq => eq.id === '2')?.status).toBe('in-use');
      expect(state.equipment.find(eq => eq.id === '3')?.status).toBe('dirty');
    });
  });

  // =============================================================================
  // TEMPLATE MANAGEMENT
  // =============================================================================

  describe('Template Management', () => {
    test('should add a new template', () => {
      const store = createTestStore();
      const template = createMockSession({ id: 'template-1', name: 'Breakfast Prep' });

      store.dispatch(addTemplate(template));
      const state = store.getState().prep;

      expect(state.templates).toHaveLength(1);
      expect(state.templates[0]).toEqual(template);
    });

    test('should add multiple templates', () => {
      const store = createTestStore();
      const template1 = createMockSession({ id: 'template-1', name: 'Breakfast Prep' });
      const template2 = createMockSession({ id: 'template-2', name: 'Lunch Prep' });

      store.dispatch(addTemplate(template1));
      store.dispatch(addTemplate(template2));
      const state = store.getState().prep;

      expect(state.templates).toHaveLength(2);
      expect(state.templates[0].name).toBe('Breakfast Prep');
      expect(state.templates[1].name).toBe('Lunch Prep');
    });

    test('should delete a template by id', () => {
      const template1 = createMockSession({ id: 'template-1', name: 'Breakfast Prep' });
      const template2 = createMockSession({ id: 'template-2', name: 'Lunch Prep' });

      const store = createTestStore({
        currentSession: null,
        pastSessions: [],
        equipment: [],
        templates: [template1, template2],
        loading: false,
        error: null,
      });

      store.dispatch(deleteTemplate('template-1'));
      const state = store.getState().prep;

      expect(state.templates).toHaveLength(1);
      expect(state.templates[0].id).toBe('template-2');
    });

    test('should do nothing when deleting non-existent template', () => {
      const template1 = createMockSession({ id: 'template-1', name: 'Breakfast Prep' });

      const store = createTestStore({
        currentSession: null,
        pastSessions: [],
        equipment: [],
        templates: [template1],
        loading: false,
        error: null,
      });

      store.dispatch(deleteTemplate('non-existent'));
      const state = store.getState().prep;

      expect(state.templates).toHaveLength(1);
      expect(state.templates[0].id).toBe('template-1');
    });
  });

  // =============================================================================
  // LOADING & ERROR STATE
  // =============================================================================

  describe('Loading & Error State', () => {
    test('should set loading to true', () => {
      const store = createTestStore();

      store.dispatch(setLoading(true));
      const state = store.getState().prep;

      expect(state.loading).toBe(true);
    });

    test('should set loading to false', () => {
      const store = createTestStore({ loading: true, error: null, currentSession: null, pastSessions: [], equipment: [], templates: [] });

      store.dispatch(setLoading(false));
      const state = store.getState().prep;

      expect(state.loading).toBe(false);
    });

    test('should set error message', () => {
      const store = createTestStore();

      store.dispatch(setError('Something went wrong'));
      const state = store.getState().prep;

      expect(state.error).toBe('Something went wrong');
    });

    test('should clear error message', () => {
      const store = createTestStore({
        loading: false,
        error: 'Previous error',
        currentSession: null,
        pastSessions: [],
        equipment: [],
        templates: [],
      });

      store.dispatch(setError(null));
      const state = store.getState().prep;

      expect(state.error).toBeNull();
    });
  });

  // =============================================================================
  // ASYNC THUNKS - fetchCurrentSession
  // =============================================================================

  describe('fetchCurrentSession thunk', () => {
    test('should set loading state on pending', async () => {
      mockedPrepApi.getCurrentSession.mockReturnValue(
        new Promise(() => {}) // Never resolves
      );

      const store = createTestStore();
      store.dispatch(fetchCurrentSession());

      const state = store.getState().prep;
      expect(state.loading).toBe(true);
      expect(state.error).toBeNull();
    });

    test('should fetch current session successfully', async () => {
      const session = createMockSession();
      mockedPrepApi.getCurrentSession.mockResolvedValue({
        success: true,
        data: session,
      });

      const store = createTestStore();
      await store.dispatch(fetchCurrentSession());

      const state = store.getState().prep;
      expect(state.loading).toBe(false);
      expect(state.currentSession).toEqual(session);
      expect(state.error).toBeNull();
    });

    test('should handle API error on fetch current session', async () => {
      mockedPrepApi.getCurrentSession.mockResolvedValue({
        success: false,
        error: 'Network error',
      });

      const store = createTestStore();
      await store.dispatch(fetchCurrentSession());

      const state = store.getState().prep;
      expect(state.loading).toBe(false);
      expect(state.currentSession).toBeNull();
      expect(state.error).toBe('Network error');
    });

    test('should handle null data from API', async () => {
      mockedPrepApi.getCurrentSession.mockResolvedValue({
        success: true,
        data: null,
      });

      const store = createTestStore();
      await store.dispatch(fetchCurrentSession());

      const state = store.getState().prep;
      expect(state.loading).toBe(false);
      expect(state.currentSession).toBeNull();
    });
  });

  // =============================================================================
  // ASYNC THUNKS - startSessionAsync
  // =============================================================================

  describe('startSessionAsync thunk', () => {
    test('should start session successfully via API', async () => {
      const sessionData = {
        name: 'Dinner Prep',
        tasks: [createMockTask()],
        estimatedDuration: 30,
      };

      const responseSession = createMockSession({
        ...sessionData,
        id: 'session-123',
      });

      mockedPrepApi.startSession.mockResolvedValue({
        success: true,
        data: responseSession,
      });

      const store = createTestStore();
      await store.dispatch(startSessionAsync(sessionData));

      const state = store.getState().prep;
      expect(state.loading).toBe(false);
      expect(state.currentSession).toMatchObject({
        id: 'session-123',
        status: 'in-progress',
      });
      expect(state.currentSession?.startTime).toBeTruthy();
    });

    test('should handle API error on start session', async () => {
      const sessionData = {
        name: 'Dinner Prep',
        tasks: [createMockTask()],
        estimatedDuration: 30,
      };

      mockedPrepApi.startSession.mockResolvedValue({
        success: false,
        error: 'Failed to start session',
      });

      const store = createTestStore();
      await store.dispatch(startSessionAsync(sessionData));

      const state = store.getState().prep;
      expect(state.loading).toBe(false);
      expect(state.currentSession).toBeNull();
      expect(state.error).toBe('Failed to start session');
    });

    test('should set loading state during start session', async () => {
      const sessionData = {
        name: 'Dinner Prep',
        tasks: [createMockTask()],
        estimatedDuration: 30,
      };

      mockedPrepApi.startSession.mockReturnValue(
        new Promise(() => {}) // Never resolves
      );

      const store = createTestStore();
      store.dispatch(startSessionAsync(sessionData));

      const state = store.getState().prep;
      expect(state.loading).toBe(true);
    });
  });

  // =============================================================================
  // ASYNC THUNKS - endSessionAsync
  // =============================================================================

  describe('endSessionAsync thunk', () => {
    test('should end session successfully via API', async () => {
      const session = createMockSession({ id: 'session-1', status: 'in-progress' });
      const equipment: Equipment[] = [
        createMockEquipment({ id: '1', status: 'in-use' }),
      ];

      mockedPrepApi.endSession.mockResolvedValue({
        success: true,
        data: 'session-1',
      });

      const store = createTestStore({
        currentSession: session,
        pastSessions: [],
        equipment,
        templates: [],
        loading: false,
        error: null,
      });

      await store.dispatch(endSessionAsync('session-1'));

      const state = store.getState().prep;
      expect(state.currentSession).toBeNull();
      expect(state.pastSessions).toHaveLength(1);
      expect(state.pastSessions[0].status).toBe('completed');
      expect(state.equipment[0].status).toBe('dirty');
    });

    test('should handle ending session with no current session', async () => {
      mockedPrepApi.endSession.mockResolvedValue({
        success: true,
        data: 'session-1',
      });

      const store = createTestStore();
      await store.dispatch(endSessionAsync('session-1'));

      const state = store.getState().prep;
      expect(state.currentSession).toBeNull();
      expect(state.pastSessions).toHaveLength(0);
    });
  });

  // =============================================================================
  // ASYNC THUNKS - updateTaskStatusAsync
  // =============================================================================

  describe('updateTaskStatusAsync thunk', () => {
    test('should update task status successfully via API', async () => {
      const task = createMockTask({ id: 'task-1', status: 'pending' });
      const session = createMockSession({ tasks: [task] });

      mockedPrepApi.updateTaskStatus.mockResolvedValue({
        success: true,
        data: { taskId: 'task-1', status: 'completed' },
      });

      const store = createTestStore({
        currentSession: session,
        pastSessions: [],
        equipment: [],
        templates: [],
        loading: false,
        error: null,
      });

      await store.dispatch(updateTaskStatusAsync({
        sessionId: 'session-1',
        taskId: 'task-1',
        status: 'completed',
      }));

      const state = store.getState().prep;
      expect(state.currentSession?.tasks[0].status).toBe('completed');
    });

    test('should handle updating task with no current session', async () => {
      mockedPrepApi.updateTaskStatus.mockResolvedValue({
        success: true,
        data: { taskId: 'task-1', status: 'completed' },
      });

      const store = createTestStore();
      await store.dispatch(updateTaskStatusAsync({
        sessionId: 'session-1',
        taskId: 'task-1',
        status: 'completed',
      }));

      const state = store.getState().prep;
      expect(state.currentSession).toBeNull();
    });
  });

  // =============================================================================
  // ASYNC THUNKS - fetchTemplates
  // =============================================================================

  describe('fetchTemplates thunk', () => {
    test('should fetch templates successfully', async () => {
      const templates = [
        createMockSession({ id: 'template-1', name: 'Breakfast' }),
        createMockSession({ id: 'template-2', name: 'Lunch' }),
      ];

      mockedPrepApi.getTemplates.mockResolvedValue({
        success: true,
        data: templates,
      });

      const store = createTestStore();
      await store.dispatch(fetchTemplates());

      const state = store.getState().prep;
      expect(state.templates).toHaveLength(2);
      expect(state.templates[0].name).toBe('Breakfast');
      expect(state.templates[1].name).toBe('Lunch');
    });

    test('should handle empty templates response', async () => {
      mockedPrepApi.getTemplates.mockResolvedValue({
        success: true,
        data: [],
      });

      const store = createTestStore();
      await store.dispatch(fetchTemplates());

      const state = store.getState().prep;
      expect(state.templates).toHaveLength(0);
    });

    test('should handle null templates data', async () => {
      mockedPrepApi.getTemplates.mockResolvedValue({
        success: true,
        data: null,
      });

      const store = createTestStore();
      await store.dispatch(fetchTemplates());

      const state = store.getState().prep;
      expect(state.templates).toHaveLength(0);
    });
  });

  // =============================================================================
  // ASYNC THUNKS - createTemplateAsync
  // =============================================================================

  describe('createTemplateAsync thunk', () => {
    test('should create template successfully via API', async () => {
      const templateData = {
        name: 'Dinner Prep',
        tasks: [createMockTask()],
        status: 'pending' as const,
        estimatedDuration: 30,
      };

      const createdTemplate = createMockSession({
        ...templateData,
        id: 'template-123',
      });

      mockedPrepApi.createTemplate.mockResolvedValue({
        success: true,
        data: createdTemplate,
      });

      const store = createTestStore();
      await store.dispatch(createTemplateAsync(templateData));

      const state = store.getState().prep;
      expect(state.templates).toHaveLength(1);
      expect(state.templates[0].id).toBe('template-123');
      expect(state.templates[0].name).toBe('Dinner Prep');
    });

    test('should handle null template data from API', async () => {
      const templateData = {
        name: 'Dinner Prep',
        tasks: [createMockTask()],
        status: 'pending' as const,
        estimatedDuration: 30,
      };

      mockedPrepApi.createTemplate.mockResolvedValue({
        success: true,
        data: null,
      });

      const store = createTestStore();
      await store.dispatch(createTemplateAsync(templateData));

      const state = store.getState().prep;
      expect(state.templates).toHaveLength(0);
    });
  });

  // =============================================================================
  // ASYNC THUNKS - fetchPastSessions
  // =============================================================================

  describe('fetchPastSessions thunk', () => {
    test('should fetch past sessions successfully', async () => {
      const pastSessions = [
        createMockSession({ id: 'session-1', status: 'completed', name: 'Breakfast' }),
        createMockSession({ id: 'session-2', status: 'completed', name: 'Lunch' }),
      ];

      mockedPrepApi.getPastSessions.mockResolvedValue({
        success: true,
        data: pastSessions,
      });

      const store = createTestStore();
      await store.dispatch(fetchPastSessions(10));

      const state = store.getState().prep;
      expect(state.pastSessions).toHaveLength(2);
      expect(state.pastSessions[0].name).toBe('Breakfast');
      expect(state.pastSessions[1].name).toBe('Lunch');
    });

    test('should use default limit if not provided', async () => {
      const pastSessions = [
        createMockSession({ id: 'session-1', status: 'completed' }),
      ];

      mockedPrepApi.getPastSessions.mockResolvedValue({
        success: true,
        data: pastSessions,
      });

      const store = createTestStore();
      await store.dispatch(fetchPastSessions());

      expect(mockedPrepApi.getPastSessions).toHaveBeenCalledWith(10);
    });

    test('should handle empty past sessions response', async () => {
      mockedPrepApi.getPastSessions.mockResolvedValue({
        success: true,
        data: [],
      });

      const store = createTestStore();
      await store.dispatch(fetchPastSessions(5));

      const state = store.getState().prep;
      expect(state.pastSessions).toHaveLength(0);
    });

    test('should handle null past sessions data', async () => {
      mockedPrepApi.getPastSessions.mockResolvedValue({
        success: true,
        data: null,
      });

      const store = createTestStore();
      await store.dispatch(fetchPastSessions(5));

      const state = store.getState().prep;
      expect(state.pastSessions).toHaveLength(0);
    });
  });

  // =============================================================================
  // ERROR HANDLING - ASYNC THUNKS
  // =============================================================================

  describe('Error Handling - Async Thunks', () => {
    test('should handle error with message in fetchCurrentSession', async () => {
      mockedPrepApi.getCurrentSession.mockResolvedValue({
        success: false,
        error: 'Database connection failed',
        message: 'Could not connect to database',
      });

      const store = createTestStore();
      await store.dispatch(fetchCurrentSession());

      const state = store.getState().prep;
      expect(state.error).toBe('Could not connect to database');
    });

    test('should handle error without message in startSessionAsync', async () => {
      const sessionData = {
        name: 'Dinner Prep',
        tasks: [createMockTask()],
        estimatedDuration: 30,
      };

      mockedPrepApi.startSession.mockResolvedValue({
        success: false,
        error: 'Unknown error',
      });

      const store = createTestStore();
      await store.dispatch(startSessionAsync(sessionData));

      const state = store.getState().prep;
      expect(state.error).toBe('Unknown error');
    });

    test('should handle network rejection in fetchTemplates', async () => {
      mockedPrepApi.getTemplates.mockRejectedValue(new Error('Network error'));

      const store = createTestStore();
      await store.dispatch(fetchTemplates());

      const state = store.getState().prep;
      expect(state.templates).toHaveLength(0);
    });
  });

  // =============================================================================
  // TIME ESTIMATION
  // =============================================================================

  describe('Time Estimation', () => {
    test('should calculate total session duration from tasks', () => {
      const tasks = [
        createMockTask({ id: 'task-1', duration: 10 }),
        createMockTask({ id: 'task-2', duration: 15 }),
        createMockTask({ id: 'task-3', duration: 20 }),
      ];

      const session = createMockSession({
        tasks,
        estimatedDuration: 45,
      });

      const store = createTestStore();
      store.dispatch(startSession(session));

      const state = store.getState().prep;
      expect(state.currentSession?.estimatedDuration).toBe(45);
    });

    test('should preserve task durations when updating status', () => {
      const task = createMockTask({ id: 'task-1', duration: 25, status: 'pending' });
      const session = createMockSession({ tasks: [task] });

      const store = createTestStore({
        currentSession: session,
        pastSessions: [],
        equipment: [],
        templates: [],
        loading: false,
        error: null,
      });

      store.dispatch(updateTaskStatus({ taskId: 'task-1', status: 'completed' }));
      const state = store.getState().prep;

      expect(state.currentSession?.tasks[0].duration).toBe(25);
      expect(state.currentSession?.tasks[0].status).toBe('completed');
    });
  });

  // =============================================================================
  // INTEGRATION TESTS - COMPLEX WORKFLOWS
  // =============================================================================

  describe('Integration - Complex Workflows', () => {
    test('should handle complete session lifecycle', () => {
      const store = createTestStore();

      // Start session
      const session = createMockSession({
        tasks: [
          createMockTask({ id: 'task-1', status: 'pending' }),
          createMockTask({ id: 'task-2', status: 'pending' }),
        ],
      });

      store.dispatch(startSession(session));
      let state = store.getState().prep;
      expect(state.currentSession?.status).toBe('in-progress');

      // Update equipment
      store.dispatch(setEquipmentStatus({
        equipmentId: '1',
        status: 'in-use',
        currentTask: 'task-1',
      }));

      // Complete first task
      store.dispatch(updateTaskStatus({ taskId: 'task-1', status: 'completed' }));
      state = store.getState().prep;
      expect(state.currentSession?.tasks[0].status).toBe('completed');

      // Start second task
      store.dispatch(updateTaskStatus({ taskId: 'task-2', status: 'in-progress' }));

      // End session
      store.dispatch(endSession());
      state = store.getState().prep;

      expect(state.currentSession).toBeNull();
      expect(state.pastSessions).toHaveLength(1);
      expect(state.pastSessions[0].tasks[0].status).toBe('completed');
      expect(state.equipment.find(eq => eq.id === '1')?.status).toBe('dirty');
    });

    test('should handle template creation and usage workflow', async () => {
      const templateData = {
        name: 'Weekly Meal Prep',
        tasks: [
          createMockTask({ id: 'task-1', name: 'Chop vegetables' }),
          createMockTask({ id: 'task-2', name: 'Cook rice' }),
        ],
        status: 'pending' as const,
        estimatedDuration: 60,
      };

      const createdTemplate = createMockSession({
        ...templateData,
        id: 'template-1',
      });

      mockedPrepApi.createTemplate.mockResolvedValue({
        success: true,
        data: createdTemplate,
      });

      const store = createTestStore();

      // Create template
      await store.dispatch(createTemplateAsync(templateData));
      let state = store.getState().prep;
      expect(state.templates).toHaveLength(1);

      // Use template to start session
      store.dispatch(startSession(state.templates[0]));
      state = store.getState().prep;
      expect(state.currentSession?.name).toBe('Weekly Meal Prep');
      expect(state.currentSession?.tasks).toHaveLength(2);
    });
  });
});
